# pylint: disable=all
# type: ignore
#region Code without hints

# List of all questions to be revised.  Every question is a flavour of one I got wrong, added here each time.
# One set of '*****' indicates I got the question wrong again a number of days after previously revising it.  Additional sets, wrong again, and so on.
# All answers are corrected before this document is saved by me.  If any are blank I deleted the answer as extra reminder to re-revise that question.  No answers will be 'left incorrect' before I upload this file to github.



# Q10 Which of the following lines describe a true condition?                               20-2

1. 'smith' > 'Smith' 

2. 'Smiths' < 'Smith' 

3. 'Smith' > '1000' 

4. '11' < '8' 

5. '!' < '5'

# Answer: True, False, False, True, False












# Q12 A) What is the expected result of the following code?         mmmmm      mmmmm           25-1            19-2

s1 = '45.6'
i = int(s1)
s2 = str(i)
f = float(s2)
print(s1 == s2)

# Answer: ValueError

# Q12 B) What if s1 was a float?

# Answer: False



# Q13 What is the expected value of the result variable after the following code is executed?                   20-2

import math
result = math.e == math.exp(1)

# Answer: 






# Q15 Which of the platform module's functions will you use to determine the name of the CPU running inside your computer?              20-2

# Answer:  FIND OUT WHAT HAPPENS FOR PLATFORM.PROCESSOR AND PLATFORM.MACHINE FOR WINDOWS.








# Q16 You want to prevent your module's user from running your code as an ordinary script. How will you achieve such an effect?                 20-2

# Answer:
import sys
if __name__ == '__main__':
    sys.exit() ##### sys or os???























'''                                                                                                            mmmmm            mmmmm           21-1            20-2
Q25:
A) What apt command removes installed software? And what pip command removes an installed package?
# Answer: sudo apt remove packagename       pip uninstall packagename

B) What is the pip command to view all installed packages?
# Answer:  pip list

C) What is the pip command to view a package's dependencies?
# Answer: pip show packagename

D) What is the pip command to search for packages?
# Answer: pip search packagename (no longer works)

E) What is the pip command to update a package?
# Answer: pip install -U packagename

F) In the command `pip --version`, is 'version' a command or an option?
# Answer: An option of the 'pip' command itself                                       'Version' is' a general option of the pip command itself.  The typical usage is `pip <command> [options] <target>`.  But here, pip is the only command, so the --version flag follows directly.

G) What is the pip command if you only wanted to install version 1.0.4 of a package for the current user?
# Answer: pip install --user 'packagename==1.0.4'
'''



''' Q26                                                 mmmmm
# Explain how to:
1. Check pip version?
2. Install pip package?
3. Install pip package only for the current user ?
'''
# Answer: 
1. pip --version
2. pip install packagename
3. pip install --user packagename






# b) What is the output of the following snippet?                                                                           21-1           REDO FOR WINDOWS FOR: platform.machine(), platform.processor(),                      

import platform
print(platform.machine(), platform.processor(), platform.system(), platform.platform(), platform.version())

# Answer:    
"""
x86_64
x86_64
Linux                               or  Windows
Linux Kernel Build Info and CPU     or  (Windows):   Windows + Build Info & Version + CPU
Linux Distribution + version        or  (Windows):   Shorter version number only
"""













""" Answers (for referece)
#        x86 x86 linux linux_kernel_info linux_distro
# or     x86 x86 windows 'windows 10 [build_info]' build_info
"""












# Q34 What is the result of:      *****      *****      mmmmm      mmmmm
s = '123456789'
for i in range(len(s)):
    print(math.floor(int(s[i])) and math.ceil(int(s[i])))

''' Answer:
1
2
3
4
5
6
7
8
9
'''



# Q35 What is the output of print(math.radians(90))?                                        20-2
# Answer: 







# Q44 a): Name four list methods that return a value and seven that don't.                                  

'''
Answer:
pop
count
index
????copy                                                                                20-2

insert
append
extend
reverse
sort
remove
clear


'''



# Q45: How many arguments does the string class's 'join' method take?  And what data type does it take?       *****                 20-2

# Answer: 









''' Q48: Write three snippets to iterate through the dictionary:                         20-2
a) its key-value pairs
b) only its keys
c) only its values
'''

dic = {1: 'one', 2: 'two', 3: 'three'}

''' Answer:
a) 
b) for i in dic.keys()
c) for i in dic.values()

'''




# Q49: A) What is the ouput of this?    B) And what if we removed the first two lines?           mmmmm                20-2

lst_obj = (-1, 11, 0)
lst_obj[0] += 1
obj = range(1, 11, 0)

# Answer (A): TypeError.
# Answer (B): 









# Q53: c) If map() and filter() are multiple choice answers in an exam, how can we quickly eliminate map()?                     21-1

# Answer: The map() answers will have the same number of elemements, but the filter() ones may have less.                                                                                                                                                    >>>>>>>>>>>>>>>>>>>>>>>> If there is a smaller number of elements in the output list vs the input target.










# Q55: What is the output?          nnnnn                       20-2

elements = {}
for character in 'Gandalf':
    if character in 'Saruman':
        elements[ord(character)] = character
else:
    elements[ord('u')] = 'u'

for key in elements.keys():
    print(elements[key], end=' ')

# Answer: 











# Q58 c): What are the rules for the 'import' keyword if used without 'from'?                       21-1            20-2

# Answer:                                                                                                                                                                               must be a module or a package.  If its only a package, the package's __init__.py file may need to be updated to access modules within it.




























""" Q75: List 7 open() modes and their behaviour.

r: reads from beginning; file must exist or raises FileNotFoundError
w: creates or truncates; existing file not required.

r+: reads & update; reads or writes starting at the beginning; file must exist.
w+: write & update: writes or reads from the beginning; existing file not required.

x: creates a file for writing at the beginning; raises FileExistsError if file exists. Safer alternative to 'w'.
a: append opens or creates a file for writing at the end; existing file not required.
a+: opens (or creates) a file for appending at the end; existence not required; writes always move the position (back) to the end.

"""









# Q78: True or false for each of these?                                                                     21-2 (mix up)

print(bool(''), bool([]), bool(0,), bool({}), bool(None), end='')
print('', bool([[]]), bool((0,)))

# Answer: 
"""
F, F, F, F, F, T, T
"""









# b) Which of the following is a true statement? (Select 2 Answers)                         21-2

"""
Unicode is a standard

UTF-8 is an encoding

Unicode is an encoding

UTF-8 is a standard

UTF-8 is the only encoding apart from ASCII
"""

# Answer: Unicode is a standard and UTF-8 is an implimentation of it.







# Q84: What are each of these constants?                                                   22-1         Got all correct (26-1)          21-2

"""
errno.EACCES → 

# Answer: 

errno.EBADF → 

# Answer: 

errno.EEXIST → 

# Answer: 

errno.EFBIG → 

# Answer: 

errno.EISDIR → 

# Answer: 

errno.EMFILE → 

# Answer: 

errno.ENOENT → 

# Answer: 

errno.ENOSPC → 

# Answer: 

"""











# Q88: What is the expected output of the following code snippet?                       21-2 (also see Q94)

class GalaxyError(Exception):
    pass
 
try:
    raise Exception("X", "Y")
except GalaxyError:
    print("Greetings", end=" ")
finally:
    print("Farewell")

# Answer: 








# Q90: 
# a) What is the expected output of the following code snippet?                 8-2             21-2

creature_stats = {'goblin':1, 'troll':2}
try:
    creature_stats[1]
except IndexError:
    print('Cave', end=' ')
except Exception as exc:
    print(exc.args, end=' ')

# Answer: 

# b) What distinguishes KeyError's error argument handling, specifically when accessing a non-existent key in a dictionary, from that of other Python error types?

# Answer:                                                                                                                                                                                      The non-existent key itself is passed as an argument, instead of a description of the error.






# Q91: What is the expected output of the following code snippet?                 8-2

string_sequence = "def"
 
for element in string_sequence:
    element = 'y'
 
print(string_sequence)

# Answer: def (also, see extra info below):


"""
string_sequence = "def"
 
for element in string_sequence:
    print(element)                 #extra print() for tracking
    element = 'y'
    print(element)                 #extra print() for tracking
 
print(string_sequence)

Console
d
y #
e
y #
f
y #
def

"""






# Q92: Given the following classes:                                             8-2             correct_but_MORE_PRACTICE_NEEDED__21-2

class Alpha:
    pass
class Beta(Alpha):
    pass
class Gamma(Beta):
    pass
class Delta(Alpha):
    pass

# Which of the following are correct declarations of subclasses? (Select 2 Answers)

class subclass1(Alpha, Beta): # a
    pass

class subclass2(Gamma, Delta): # b
    pass

class subclass3(Alpha, Delta): # c
    pass

class subclass4(Beta, Gamma): # d
    pass

class subclass5(Delta, Gamma): # e
    pass


# Answer: b, e





# Q93:                                                                      9-2

"""
The file abc.txt contains the following 3 lines of text:

abc
def
ghi

The output of the below snippet is: 
<_io.TextIOWrapper name='abc.txt' mode='r' encoding='cp1252'>
What would happen if we tried to iterate over the stream directly?
"""

file = open('abc.txt')
print(file)

# Answer: Acting as an iterator, io.TextIOWrapper calls __next__, printing the text up to the next new line character until StopIteration is raised when reaching EOF.















# Q94: What is the expected output of the following code snippet?                 8-2
class ExampleException(Exception):
    def __init__(self, msg):
        super().__init__(msg)
    
    def __str__(self):
        return 'a'

try:
    raise ExampleException('test')
except Exception as e:                      # see note (scroll right)                                                                                                           This line does NOT alter the instance of the exception that was raised (see below**)!
    print(e)

# Answer: a








# Q96: What is the output of the following snippet of code?                 8-2             21-2

class A:
    pass
class B:
    pass
class C(B):
    pass
 
c = C()
print(isinstance(c, (B,A)))

# 





# Q97: A)Which of the following snippets outputs 'abc' to the screen? (Select two answers).             21-2

# Option A
print(sorted("abc"))

# Option B
temporary_variable = "abc".sort()
print(str(temporary_variable))

# Option C
print(''.join(sorted("abc")))

# Option D
temporary_variable2 = list("abc")
temporary_variable2.sort()
print(''.join(temporary_variable2))

# Answer: 

# B) What data type does sorted() always return?  And what can it not sort?

# Answer: sorted() always returns a list (and automatically converts other types to lists).  However, it can't sort between different data types, i.e., between 'str' and 'int'.



# Q98: What is the output of the following snippet of code?                 11-2
x = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
 
def func(data):
    res = data[0][0]
    for da in data:
        for d in da:
            if res < d:
                res = d
    return res
 
print(func(x[0]))

# Answer: 4










# Q99: What is the output of the 2 following  snippets?

class E (Exception):
	def __init__(self, message):
		self.message = message
	
	def __str__(self):
		return "it's nice to see you"

try:
    print("I feel fine")
    raise E("what a pity")
except Exception as e:
    print(e)
else:
    print("the show must go on")



"""Answer: 
what a pity
it's nice to see you
"""



"""
Python exceptions are designed so that more general except branches are capable of catching a wider number of exceptions.  This means a superclass in
the except branch can catch its subclass exceptions.
To catch a more concrete exception when both concrete and non-concrete branches exist, the subclasse(s) or 'more concrete' exception(s) should be placed first.
"""





class E (Exception):
	def __init__(self, message):
		self.message = message
	
	def __str__(self):
		return "it's nice to see you"

try:
    print("I feel fine")
    raise Exception("what a pity")
except E as e:
    print(e)
else:
    print("the show must go on")



# Answer: Not caught.



"""
However, if the except branch is a subclass of the exception (i.e., the exception being RAISED is the parent), it can not catch the exception.  This is similar
to how an instance of a superclass doesn't have the attributes of its subclasses.

If subclasses could catch superclass exceptions, it would lead to a scenario where very specific handlers are invoked for general problems they're not designed
to address directly, potentially leading to inappropriate error handling.
"""














# Q100: What is the output?
print('' in '', '' in ' a')

# Answer: True True







# Q101 - Error Handling

# Q: Which of the following is false?


#1 A try statement can have a finally clause without an except clause.

#2 A try statement can have one or more finally clauses.

#3 A try statement can have one or more except clauses.

#4 A try statement can have a finally clause and an except clause.

# Answer: 2






# Q102: 

# A) Given the code below, complete the display() method body in a way that will ensure that the retrieve() method is properly invoked.

class Artifact:
    def __init__(self):
        self.collection = 1
 
    def retrieve(self):
        return self.collection
 
    def display(self):
        # Insert a method here
 
 
item = Artifact()
item.display()

# (Select two answers.)

print(Artifact.retrieve(self))

print(Artifact.retrieve())

print(retrieve())

print(self.retrieve())

# Answer: 1st, 4th.




# B) Comment out the incorrect lines, make two small corrections, then run the program to check it works.               CORRECT_BUT_NEED_MORE_PRACTICE_21-2

class ScienceExperiment:
    variable = 'Experiment Data'
    def __init__(self):
        experiment_note = 'Note Content'
        print(self.experiment_note)


    def record(self):
        observation = 'Observation Details'
        print(self.observation)

test = ScienceExperiment()
test.record()

ScienceExperiment.experiment_note
ScienceExperiment.record()
print(test.__dict__)
print(test.experiment_note)


# Answer (did it work)?: yes, you can't do class.instance_variable, as it'll look for a class variable that doesn't exist. You also can't 'only' do class.instance_method() because the method would be missing the 1 required positional arg: 'self'.                                                                                                                                                                             # Hint: 'self'









# Q103: 

# A) Is the result of the following line 0 or 0.0?

print(1 // 2 * 3)


# Answer: 0


# B) What's the result this time?  Why?

print(9 // 3 // 1.0)

# Answer: 3.0                                                                                                                                                    # The divide (/) operator always returns a float.  The floor divide (aka int division) operator (//) truncates to an integer if all operands are ints.  If at least one operand is a float, '//' returns a float.






#Q104: What is the output and why?

def t():
    return 'Peter'           'Wellert'

print(t())


# Answer: PeterWellert: Python concatenates the strings.






#Q105:                                                                                                  21-2

# A) Provide a detailed list of all the output for this snippet (any order will do). 

class MyClass:
    """docstring test"""

    class_var = 1
 
    def __init__(self):
        self.instance_var = 1
 
    def my_meth(self):
        pass
 
 
object = MyClass()

for i in MyClass.__dict__:
    print(i, '\t\t', MyClass.__dict__[i])


# Answer: 







"""
__module__      __main__
__dict__        <attribute '__dict__' of 'MyClass' objects>
__weakref__     <attribute '__weakref__' of 'MyClass' objects>
__doc__         docstring test

__init__        <function MyClass.__init__ at 0x...>
my_meth         <function MyClass.my_meth at 0x...>
class_var       1

Note: The dictionary can be used to access these entities directly, i.e., they're not just strings.
"""




# Q106: What is the output for each snippet?                    21-2

lst = [1, 2]
lst += (1, 2, 3)
print(lst)
# Answer: 

print([1, 2] * 2 + [3])
# Answer: 

print([1, 2] + list((3, 4)))
# Answer: 

print([1, 2] + (3, 4))
# Answer: 

lst = [1, 2]
lst.append([3, 4])
print(lst)
# Answer: 

lst = [1, 2, 3]
lst.append((1,))
print(lst)
# Answer: 

lst = [1, 2, 3]
lst += (1,)
print(lst)
# Answer: 

print([[]] * 3)
# Answer: 

tup1 = (1, 2)
tup2 = (3, 4)
print([tup1] + [tup2])
# Answer: 

lst = [1, 2, 3]
(lst.append(4), lst)[1]
print(lst)
# Answer: 

print([x for x in (1, 2)] + [y for y in [3, 4]])
# Answer: 

lst = [1, 2, 3]
lst *= (1,)
print(lst)
# Answer: 

lst = [1, 2, 3]
lst += 1,
print(lst)
# Answer: 


"""Info:

+       Concatenates two sequences of the same type, returning a new sequence.  Must be the same data types.
+=      For lists: extends the sequence in-place with elements from another sequence or iterable; for strings and tuples, concatenates and reassigns due to immutability.

*       Repeats the sequence for a given integer, returning a new sequence.
*=      Repeats the sequence in-place for lists; for strings and tuples, creates and reassigns a new repeated sequence.  Integer required:  `[1, 2, 3] *= [1]` will raise a TypeError.


"""




# Q107: What does each command do?

cd ../
cd ./
cd /

"""
Answers:
up a level
cwd
root


"""





# Q108: Copy to an editor and check your answer for each expression.

print(True if False else True) # 
print(True if True else False) # 
print('Yes' if False else 'No') # 
print(False if False else True) # 
print(0 if True else 1) # 
print(True if False else False) # 
print('A' if not False else 'B') # 
print(False if True else False) # 
print('Python' if 10 > 5 else 'Java') # 
print(False if True else True) # 
print('Not Empty' if '' else 'Empty') #  
print(True if False else True) # 





# Q109: What is the output?  Why?

class Un:
    value = "Eins"
 
    def say(self):
        return self.value.lower()
  
class Deux(Un):
    value = "Zwei"
  
class Troi(Un):
    def say(self):
        return self.value.upper()
  
class Quatre(Troi, Deux):
    pass

d = Quatre()
b = Deux()

print(Un.value, Deux.value, d.value, b.value)

# Answer: Eins, Zwei, Zwei, Zwei


















# Q: What is the output?      *****      *****      mmmmm      mmmmm

s = '123456'
even_sum = 0
odd_product = 1

for i in range(len(s)):
    num = int(s[i])
    if i % 2 == 0:
        even_sum += num
    else:
        odd_product *= num

print("Sum of numbers at even indices:", even_sum)
print("Product of numbers at odd indices:", odd_product)

''' Answer:

'''





# Q: What is the output?      mmmmm            mmmmm

s = '13579'
total = 0

for i in range(1, len(s)):
    if i % 2 == 0:
        total += int(s[i])

print("Total of even-indexed numbers:", total)

# Answer: 









#  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Q [Improving speed of mental arithmetic]: What is the   F I R S T   and   L A S T   number printed from each of the following snippets?:

s = '0'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 0



s = '01'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 01



s = 'AB'
for i in range(len(s)):
    print(s[i], end='')


# Answer: AB



s = '0123'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 03



s = '456789'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 49



s = '123456789'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 19



s = '23456789'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 29



s = '67890'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 60



s = '01234567890123456789'
for i in range(len(s)):
    print(s[i], end='')


# Answer: 09



s = 'g8 49g'
for i in range(len(s)):
    print(s[i], end='')


# Answer: gg

# Q# b) What do all these answers have in common?
# Answer: When iterating over an iterable's length with range in a loop, if the operations within the loop don't modify the elements or their order, the output always mirrors the original iterable.

# Q# c) What is: 1 % 2, 0 % 1, 2 % 1 ?






# Answer: 1, 0, 0

# Q# d) Answer the below snippets:

s = '0'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 0



s = '01'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 0



s = '0123'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 2



s = '234'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 6



s = '234567'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 12



s = '013456'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 8



s = '2345678901'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 20



s = '12345'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 9



s = '3456789'
sum1 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
print(sum1)


# Answer: 24






# Q# e) Answer the below snippets:

s = '0'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



""" Answer: 
0
0
"""



s = '01'
sum = 0
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



""" Answer: 
0
1
"""




s = '0123'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



# Answer: 2, 4




s = '234'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



# Answer: 6, 3




s = '234567'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)


# Answer: 12, 15




s = '013456'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)


# Answer: 8, 11



s = '2345678901'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



# Answer: 20, 25




s = '12345'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



# Answer: 9, 6





s = '3456789'
sum1 = 0
sum2 = 0
for i in range(len(s)):
    x = int(s[i])
    if i % 2 == 0:
        sum1 += x
    else:
        sum2 += x
print(sum1)
print(sum2)



# Answer: 24, 18






l = [0]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: []






l = [0, 1]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [1]





l = [0, 1, 2]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [1]







l = [0, 1, 2, 3]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [1, 9]






l = [0, 1, 2, 3, 4]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [1, 9]







l = [0, 1, 2, 3, 4, 5]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [1, 9, 25]






l = [1, 2]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [4]






l = [1, 2, 3]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [4]







l = [1, 2, 3, 4, 5]
nl = [e**2 for e in l if l.index(e) % 2 == 1]
print(nl)



# Answer: [4, 16]





l = [0]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0]






l = [0, 1]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0]





l = [0, 1, 2]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0, 4]







l = [0, 1, 2, 3]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0, 4]






l = [0, 1, 2, 3, 4]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0, 4, 16]







l = [0, 1, 2, 3, 4, 5]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [0, 4, 16]






l = [1, 2]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [1]






l = [1, 2, 3]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [1, 9]







l = [1, 2, 3, 4, 5, 6, 7]
nl = [e**2 for e in l if l.index(e) % 2 == 0]
print(nl)



# Answer: [1, 9, 25, 49]







#################################################################################################################







# MULTIPLE CHOICE:

list1 = [3, 4]
list2 = [4, 5, 6]

a = list(filter(lambda x: x in list1, list2))
print(a)

"""
A) [3, 4]
B) [5, 6]
C) []
D) [4]
"""


# Answer: D






list1 = [2, 4, 6]
list2 = [1, 2, 3, 4]

a = list(filter(lambda x: x in list1, list2))
print(a)

"""
A) [2, 4]
B) [1, 3]
C) []
D) [2, 3, 4]
"""

# Answer:  A) [2, 4]







list1 = [10, 20, 30]
list2 = [20, 30, 40, 50]

a = list(filter(lambda x: x in list1, list2))
print(a)

"""
A) [20, 30, 40]
B) [20, 30]
C) []
D) [10, 20, 30]
"""


# Answer: B) [20, 30]






list1 = [15, 25]
list2 = [5, 10, 15, 20, 25, 30]

a = list(filter(lambda x: x in list1, list2))
print(a)

"""
A) [15, 25]
B) [5, 10, 20, 30]
C) [10, 20, 30]
D) []
"""


# Answer: A) [15, 25]






list1 = [1, 2]
list2 = [1, 2, 3]

a = list(filter(lambda x: x not in list1, list2))
print(a)

"""
A) [2, 3]
B) []
C) [3]
D) [1, 2]
"""


# Answer: C) [3]




list1 = [5, 6, 7]
list2 = [4, 5, 6, 7, 8]

a = list(filter(lambda x: x not in list1, list2))
print(a)

"""
A) [5, 6, 7]
B) [4, 8]
C) [4, 5, 6, 7, 8]
D) []
"""


# Answer: B) [4, 8]






list1 = [2, 3, 5]
list2 = [1, 2, 3, 4, 5, 6]

a = list(filter(lambda x: x not in list1, list2))
print(a)

"""
A) [2, 3, 5]
B) [1, 4, 6]
C) [1, 2, 3, 4, 5, 6]
D) [1, 3, 5]
"""


# Answer: B) [1, 4, 6]






list1 = [3, 6, 9]
list2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]

a = list(filter(lambda x: x not in list1, list2))
print(a)

"""
A) [1, 2, 4, 5, 7, 8]
B) [3, 6, 9]
C) [1, 2, 3, 4, 5, 6, 7, 8, 9]
D) []
"""


# Answer: A) [1, 2, 4, 5, 7, 8]







list1 = ['a', 'b']
list2 = ['b', 'c', 'd']

a = list(filter(lambda x: x in list1, list2))
print(a)

"""
A) ['a', 'b']
B) ['c', 'd']
C) []
D) ['b']
"""

# Answer: D) ['b']




list1 = [7, 'x', 9]
list2 = ['y', 7, 'z', 'x']

a = list(filter(lambda x: x in list1, list2))
print('\n', a)

"""
A) []
B) ['y', 'z']
C) [7, 'x']
D) [7, 'x', 'y', 'z']
"""

# Answer: C) [7, 'x']





list1 = [15, 'apple', 20]
list2 = ['banana', 20, 'apple', 30]

a = list(filter(lambda x: x in list1, list2))
print('\n', a)

"""
A) [15, 'apple', 20]
B) ['banana', 30]
C) ['apple', 20]
D) []
"""

# Answer: C) ['apple', 20]





list1 = [40, 'orange', 50]
list2 = ['orange', 50, 'lemon', 60]

a = list(filter(lambda x: x in list1, list2))
print('\n', a)

"""
A) ['orange', 50]
B) ['lemon', 60]
C) []
D) [40, 'orange', 50]
"""

# Answer: A) ['orange', 50]





list1 = ['cat', 3]
list2 = [1, 'cat', 4, 'dog']

a = list(filter(lambda x: x not in list1, list2))
print('\n', a)

"""
A) [1, 'cat', 4, 'dog']
B) []
C) ['cat', 4]
D) [1, 4, 'dog']
"""

# Answer: d





list1 = [5, 'mouse', 8]
list2 = [7, 'mouse', 9, 'rat', 8]

a = list(filter(lambda x: x not in list1, list2))
print('\n', a)

"""
A) [7, 'mouse', 9, 'rat', 8]
B) [5, 'mouse', 8]
C) [7, 9, 'rat']
D) []
"""

# Answer: c





list1 = [2, 'bird', 'fish']
list2 = [1, 2, 'cat', 'bird', 6]

a = list(filter(lambda x: x not in list1, list2))
print('\n', a)

"""
A) [1, 'cat', 6]
B) [2, 'bird', 'fish']
C) [1, 2, 'cat', 'bird', 6]
D) [2, 'bird']
"""

# Answer: a





list1 = ['frog', 'toad', 9]
list2 = [1, 2, 'frog', 4, 'lizard', 'toad', 8, 9]

a = list(filter(lambda x: x not in list1, list2))
print('\n', a)

"""
A) [1, 2, 4, 'lizard', 8]
B) ['frog', 'toad', 9]
C) [1, 2, 'frog', 4, 'lizard', 'toad', 8, 9]
D) []
"""

# Answer: a







###################################################################################################

# FILL IN THE BLANKS (COPY/PASTE SOMEWHERE FIRST)

# Challenge 1: Intended Output [0, 0, 0, 1, 1, 1, 2, 2, 2]
print([_ for _ in range(3) for _ in range(3)])

# Challenge 2: Intended Output [2, 4, 6, 2, 4, 6, 2, 4, 6]
print([_ for _ in range(3) for _ in range(2, 7, 2)])

# Challenge 3: Intended Output ['A', 'B', 'A', 'B', 'A', 'B']
print([_ for _ in range(3) for _ in ['A', 'B']])

# Challenge 4: Intended Output [0, 2, 4, 0, 2, 4]
print([_ for _ in range(2) for _ in range(0, 6, 2)])

# Challenge 5: Intended Output [3, 3, 3, 4, 4, 4, 5, 5, 5]
print([_ for _ in range(3, 6) for _ in range(3)])

# Challenge 6: Intended Output [1, 3, 5, 1, 3, 5, 1, 3, 5]
print([_ for _ in range(3) for _ in range(1, 6, 2)])

# Challenge 7: Intended Output [0, 'x', 0, 'x', 0, 'x']
print([_ for _ in range(3) for _ in [0, 'x']])

# Challenge 8: Intended Output ['a', 'b', 'c', 'a', 'b', 'c']
print([_ for _ in range(2) for _ in ['a', 'b', 'c']])

# Challenge 9: Intended Output [10, 12, 14, 10, 12, 14, 10, 12, 14]
print([_ for _ in range(3) for _ in range(10, 15, 2)])

# Challenge 10: Intended Output [1, 3, 1, 3, 1, 3]
print([_ for _ in range(3) for _ in range(1, 4, 2)])







# Challenge 1: Intended Output [[0, 1, 2], [0, 1, 2], [0, 1, 2]]
print([[_ for j in range(3)] for _ in range(3)])

# Challenge 2: Intended Output [[2, 2, 2], [4, 4, 4], [6, 6, 6]]
print([[_ for i in range(3)] for _ in range(2, 7, 2)])

# Challenge 3: Intended Output [['A', 'A', 'A'], ['B', 'B', 'B']]
print([[_ for _ in range(3)] for _ in ['A', 'B']])

# Challenge 4: Intended Output [[0, 0], [2, 2], [4, 4]]
print([[_ for i in range(2)] for _ in range(0, 6, 2)])

# Challenge 5: Intended Output [[3, 4, 5], [3, 4, 5], [3, 4, 5]]
print([[_ for i in range(3, 6)] for _ in range(3)])

# Challenge 6: Intended Output [[1, 1, 1], [3, 3, 3], [5, 5, 5]]
print([[_ for i in range(3)] for _ in range(1, 6, 2)])

# Challenge 7: Intended Output [[0, 0, 0], ['x', 'x', 'x']]
print([[_ for i in range(3)] for _ in [0, 'x']])

# Challenge 8: Intended Output [['a', 'a'], ['b', 'b'], ['c', 'c']]
print([[_ for _ in range(2)] for _ in ['a', 'b', 'c']])

# Challenge 9: Intended Output [[10, 10, 10], [12, 12, 12], [14, 14, 14]]
print([[_ for i in range(3)] for _ in range(10, 15, 2)])

# Challenge 10: Intended Output [[1, 1, 1], [3, 3, 3]]
print([[_ for _ in range(3)] for _ in range(1, 4, 2)])




###################################################################################################




# FLAT List Comprehensions with Two Iterators (20 Challenges)

# 1
print([x + y for x in range(3) for y in range(2)])  # [0, 1, 1, 2, 2, 3]
# Answer: 

# 2
print([x * y for x in range(2) for y in range(3)])  # [0, 0, 0, 0, 1, 2]
# Answer: 

# 3
print([x - y for x in range(4) for y in range(2)])  # [0, -1, 1, 0, 2, 1, 3, 2]
# Answer: 

# 4
print([x for x in range(3) for y in range(2) if x > y])  # [1, 2, 2]
# Answer: 

# 5
print([y for x in range(2) for y in range(3) if x < y])  # [1, 2, 2]
# Answer: 

# 6
print([x * y for x in range(2) for y in range(2) if x != y])  # [0, 0]
# Answer: 

# 7
print([x + y for x in range(2) for y in range(2) if x == y])  # [0, 2]
# Answer: 

# 8
print([x - y for x in range(3) for y in range(3) if x >= y])  # [0, 1, 0, 2, 1, 0]
# Answer: 

# 9
print([x * y for x in range(2) for y in range(3) if y % 2 == 0])  # [0, 0, 0, 2]
# Answer: 

# 10
print([x + y for x in range(3) for y in range(2) if (x + y) % 2 == 0])  # [0, 2, 2]
# Answer: 




# NESTED List Comprehensions with Two Iterators (20 Challenges)

# 1
print([[x + y for x in range(2)] for y in range(2)])  # [[0, 1], [1, 2]]
# Answer: 

# 2
print([[x * y for x in range(2)] for y in range(3)])  # [[0, 0], [0, 1], [0, 2]]
# Answer: 

# 3
print([[x - y for x in range(3)] for y in range(2)])  # [[0, 1, 2], [-1, 0, 1]]
# Answer: 

# 4
print([[x for x in range(2) if x > y] for y in range(2)])  # [[1], []]
# Answer: 

# 5
print([[y for x in range(2) if x < y] for y in range(3)])  # [[], [1], [2, 2]]
# Answer: 

# 6
print([[x * y for x in range(2) if x != y] for y in range(2)])  # [[0], [0]]
# Answer: 

# 7
print([[x + y for x in range(2) if x == y] for y in range(2)])  # [[0], [2]]
# Answer: 

# 8
print([[x - y for x in range(3) if x >= y] for y in range(3)])  # [[0, 1, 2], [0, 1], [0]]
# Answer: 

# 9
print([[x * y for x in range(2) if y % 2 == 0] for y in range(3)])  # [[0, 0], [], [0, 2]]
# Answer: 

# 10
print([[x + y for x in range(2) if (x + y) % 2 == 0] for y in range(2)])  # [[0], [2]]
# Answer: 





###################################################################################################



# practice:
 2**0, 2**1, 2**2, 2**3, 2**4 and 0**2, 1**2, 2**2, 3**2, 4**2
    double last                         square left operand


# basic recursion?























#endregion